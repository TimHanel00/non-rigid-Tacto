from typing import List

from core.pipeline_block import PipelineBlock
from core.log import Log
from core.exceptions import SampleProcessingException
from .voxelize import *
from utils.vtkutils import *

class VoxelizationBlock(PipelineBlock):
    """ Block which voxelizes the provided inputs into a regular grid.

    All the results generated by this block for one DataSample will be saved into a single 
    output file. To split results across multiple files, add multiple VoxelizationBlock
    instances to your pipeline.

    TODO: GPU Usage? Drawback: would add pytorch as dependency
    """

    def __init__(
        self,
        inputs: List[dict],
        output_filename: str = "voxelized.vts",
        size: float = 0.3,
        num_cells: int = 64,
        # TODO:
        # fail_if_too_large:bool = True
    ):
        """
        Args:
            inputs: A list of all the input files to process, along with options. Each list
                entry is a dict, which can hold the following options:
                - "filename" (str): The file to voxelize (Required)
                - "name" (str): Name of the array with voxelization of the input file. Default: filename
                - "signed" (bool): Calculate signed instead of unsigned distance field. Default: False
                - "center" (bool): The voxelization grid will be centered around this file. Default: False
                - "with_arrays" (bool): Voxelizes also the vtk arrays present in filename, interpolating them to grid. Default: False
                - "interpolate_tuple1" (bool): if False, arrays with a single component (Tuple1) will not be interpolated to grid but
                their values will be spread on grid points, either as they are or as binary values. Default: True
            output_filename: Name of the output file, must end in ".vts"
            size: side-length of the generated cubic volume in meters
            num_cells: number of cells per cube side (total number of cells will be num_cells^3)
        """
        assert output_filename.lower().endswith(".vts"), \
                "VoxelizationBlock output file name must end in '.vts'!"

        self.size = size
        self.num_cells = num_cells
        self.use_gpu = False
        self.cell_size = size/(num_cells-1)

        # Parse the options for each file and add default values where necessary:
        self.input_options = []
        for inp in inputs:
            if "filename" not in inp:
                raise KeyError("Each input passed to VoxelizationBlock must contain a "+\
                        f"'filename'! The following entry does not: {inp}")
            
            # Initialize optional dict entries
            inp["name"]        = inp["filename"] if "name" not in inp else inp["name"]
            inp["signed"]      = False if "signed" not in inp else inp["signed"]
            inp["center"]      = False if "center" not in inp else inp["center"]
            inp["with_arrays"] = False if "with_arrays" not in inp else inp["with_arrays"]           
            inp["interpolate_tuple1"] = True if "interpolate_tuple1" not in inp else inp["interpolate_tuple1"]           
            
            self.input_options.append(inp)
        
        # self.input_files = input_files
        # self.output_filename = output_filename

        input_files = [inp["filename"] for inp in self.input_options]

        inputs  = input_files
        outputs = [output_filename]

        super().__init__(inputs, outputs)

    def run(
        self, 
        sample
    ):

        #TODO should we add a check to confirm that the mesh has been centered?
        grid = create_grid(self.size, self.num_cells)

        # Iterate over all the files given as 'inputs' to the block:
        for inp in self.input_options:
            # Read all files matching the filename:
            filename = inp["filename"]
            meshes = list(sample.read_all(filename))
            if len(meshes) == 0:
                raise SampleProcessingException(self, sample,
                                                f"Could not load mesh from file {filename}")
            if len(meshes) > 1:
                raise SampleProcessingException(self, sample,
                                                f"Expected one file matching {filename}, found {len(meshes)}")
            else:
                mesh = meshes[0][1]
        
            # Center grid around this mesh, if it has to
            if inp["center"]:
                tf = calc_center_transform(mesh)
                center_tf = tf.GetInverse()
                grid = apply_transform(grid, center_tf)

            Log.log(module="VoxelizationBlock", msg=f"Voxelizing {filename}")

            # Convert mesh to polydata, if needed:
            mesh = extract_surface( mesh )

            is_point_cloud = filename.endswith(".pcd")
            calc_sdf = inp["signed"]
            name = inp["name"]

            if self.use_gpu:
                raise NotImplementedError("GPU usage currently not implemented for voxelization script")
                #if not is_point_cloud:
                #    surface = extract_surface(mesh)
                #else:
                #    surface = mesh
                #distance_field_GPU(surface, grid, name)
                #if calc_SDF:
                #    try:
                #        to_SDF(surface, grid, name)
                #    except Exception as e:
                #        raise SampleProcessingException(self, sample, str(msg))
            else:
                if not is_point_cloud:
                    try:
                        surface = extract_surface(mesh)
                        distance_field(surface, grid, name, signed=calc_sdf)
                    except ArithmeticError as e:
                        msg = f"Failed to voxelize '{name}': {str(e)}"
                        raise SampleProcessingException(self, sample, msg)
                else:
                    if calc_sdf:
                        Log.log(module="VoxelizationBlock", severity="WARN",
                                msg="Cannot calculate sign of distance field " +\
                                f"for point cloud {name}. Only unsigned distance " +\
                                "fields are supported for point clouds.")
                    distance_field_from_cloud( mesh, grid, name )

            num_array = mesh.GetPointData().GetNumberOfArrays()
            if inp["with_arrays"] and num_array:
                print(f"Interpolating {num_array} arrays of {name} to grid")
                grid = interpolate_arrays_to_grid(mesh, grid, self.cell_size)

                if not "interpolate_tuple1":
                    for n in range(num_array):
                        vtk_array = mesh.GetPointData().GetArray(n)

                        if vtk_array.GetNumberOfComponents() == 1:
                            grid = spread_values_on_grid(mesh, grid, vtk_array.GetName())

        sample.write(self.outputs[0], grid)



